<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Hugo 0.20.7" />


<title>Deciphering GEMMA’s C&#43;&#43; Code - Frederick Boehm&#39;s Website</title>
<meta property="og:title" content="Deciphering GEMMA’s C&#43;&#43; Code - Frederick Boehm&#39;s Website">



  








<link href='//cdn.bootcss.com/highlight.js/9.11.0/styles/github.min.css' rel='stylesheet' type='text/css' />



<link rel="stylesheet" href="../../../../css/fonts.css" media="all">
<link rel="stylesheet" href="../../../../css/main.css" media="all">



  </head>
  <body>
    <div class="wrapper">
      <header class="header">
        <nav class="nav">
  <a href="../../../../" class="nav-logo">
    <img src="../../../../images/boehm.png"
         width="50"
         height="50"
         alt="Logo">
  </a>

  <ul class="nav-links">
    
    <li><a href="../../../../about/">About</a></li>
    
    <li><a href="../../../../curriculum-vitae/">Curriculum Vitae</a></li>
    
    <li><a href="../../../../research/">Research</a></li>
    
  </ul>
</nav>

      </header>


<main class="content" role="main">

  <article class="article">
    
    <span class="article-duration">12 min read</span>
    

    <h1 class="article-title">Deciphering GEMMA’s C&#43;&#43; Code</h1>

    
    <span class="article-date">2017/05/29</span>
    

    <div class="article-content">
      <p>My goal is to translate the C++ code in <a href="https://github.com/xiangzhou/GEMMA/blob/master/src/mvlmm.cpp"><code>GEMMA/src/mvlmm.cpp</code></a> to mathematical notation and, ultimately, to R code. Zhou’s C++ code uses the gsl C++ library.</p>
<div id="calcxhiy-c-code" class="section level2">
<h2><code>CalcXHiY</code> C++ code</h2>
<p>Let’s examine the function <code>CalcXHiY</code> which runs from line <a href="https://github.com/xiangzhou/GEMMA/blob/793ba025de8e71b49e738613e8dd9bbdd06389d4/src/mvlmm.cpp#L357-L384">357-384</a> of <code>mvlmm.cpp</code>. I reproduce them here:</p>
<pre class="cpp"><code>void CalcXHiY(const gsl_vector *eval, const gsl_vector *D_l, const gsl_matrix *X, const gsl_matrix *UltVehiY, gsl_vector *xHiy)
{
    size_t n_size=eval-&gt;size, c_size=X-&gt;size1, d_size=D_l-&gt;size;

    gsl_vector_set_zero (xHiy);

    double x, delta, dl, y, d;
    for (size_t i=0; i&lt;d_size; i++) {
        dl=gsl_vector_get(D_l, i);
        for (size_t j=0; j&lt;c_size; j++) {
            d=0.0;
            for (size_t k=0; k&lt;n_size; k++) {
                x=gsl_matrix_get(X, j, k);
                y=gsl_matrix_get(UltVehiY, i, k);
                delta=gsl_vector_get(eval, k);
                d+=x*y/(delta*dl+1.0);
            }
            gsl_vector_set(xHiy, j*d_size+i, d);
        }
    }
    /*
    cout&lt;&lt;&quot;xHiy: &quot;&lt;&lt;endl;
    for (size_t i=0; i&lt;(d_size*c_size); i++) {
        cout&lt;&lt;gsl_vector_get(xHiy, i)&lt;&lt;endl;
    }
     */
    return;
}
</code></pre>
<p>We see that Zhou uses four gsl functions repeatedly:</p>
<ol style="list-style-type: decimal">
<li><code>gsl_matrix_get</code></li>
<li><code>gsl_matrix_set</code></li>
<li><code>gsl_vector_set</code></li>
<li><code>gsl_vector_get</code></li>
</ol>
<p>From reading the documentation for these four functions - <a href="https://www.gnu.org/software/gsl/manual/html_node/Accessing-matrix-elements.html">here</a> and <a href="https://www.gnu.org/software/gsl/manual/html_node/Accessing-vector-elements.html">here</a> - my understanding is that the functions whose names end in <code>get</code> return a subset of an existing matrix or vector. For instance, the line from above:</p>
<pre class="cpp"><code>dl=gsl_vector_get(D_l, i);</code></pre>
<p>assigns to <code>dl</code> the <span class="math inline">\(i^{th}\)</span> element of the vector <code>D_l</code>.</p>
<p>The functions that end in <code>set</code> assign a value to a given element of a matrix or vector. <code>gsl_vector_set</code> requires 3 arguments, since we need to know the name of the vector, which element is to be replaced, and the value to insert at the position of replacement.</p>
<pre class="rcpp"><code>gsl_vector_set(xHiy, j*d_size+i, d);</code></pre>
<p>The code immediately above means that the value <code>d</code> is inserted into vector <code>xHiy</code> at position <code>j*d_size+i</code>.</p>
<p><a href="https://github.com/xiangzhou/GEMMA/blob/793ba025de8e71b49e738613e8dd9bbdd06389d4/src/mvlmm.cpp#L361">One of the first lines</a> in the function creates the vector <code>xHiy</code> and sets all of its entries to zero:</p>
<pre class="rcpp"><code>gsl_vector_set_zero (xHiy);</code></pre>
<p>The line</p>
<pre class="rcpp"><code>x=gsl_matrix_get(X, j, k);</code></pre>
<p>assigns to the value <code>x</code> the <span class="math inline">\((j, k)^{th}\)</span> element of matrix X.</p>
<pre class="rcpp"><code>y=gsl_matrix_get(UltVehiY, i, k);</code></pre>
<p>assigns to <code>y</code> the <span class="math inline">\((i, k)^{th}\)</span> element of <code>UltVehiY</code>.</p>
<p>Presumably <code>eval</code> is Zhou’s abbreviation of eigenvalues. <code>d</code> then is the <span class="math inline">\(k^{th}\)</span> eigenvalue from the decomposition of the kinship matrix.</p>
<p><code>x*y</code>, refers to the product of two numbers.</p>
<pre class="rcpp"><code>d+=x*y/(delta*dl+1.0);</code></pre>
<p>defines <code>d</code> to be the sum of the current value of <code>d</code> and <code>x*y/(delta*dl+1.0)</code>. In R, we would write this as:</p>
<pre class="r"><code>d &lt;- d + x * y / (delta * dl + 1)</code></pre>
<p>Note that each time we restart the loop over <code>k</code> we reset the value of <code>d</code> to zero. Note also that <code>1.0</code> is the value of every eigenvalue of the identity matrix.</p>
<p>The use of <code>1.0</code> rather than merely <code>1</code> seems peculiar to me - I’m new to C++. I imagine that <code>1</code> and <code>1.0</code> might be stored differently, which might justify the use of <code>1.0</code> over <code>1</code>.</p>
<p>Since we’re looping over <code>k</code>, it’s as if we’re taking the inner (dot) product of two vectors and defining it to be the number <code>d</code> (after the looping over k).</p>
</div>
<div id="eigenproc" class="section level2">
<h2><code>EigenProc</code></h2>
<p>I want to understand the function <code>EigenProc</code>, which occupies <a href="https://github.com/xiangzhou/GEMMA/blob/0885df136fcbe42b1665998f293953cfe8d216c6/src/mvlmm.cpp#L215-L307">lines 215-307</a> of <code>mvlmm.cpp</code>.</p>
<p>The first several lines allocate matrices with dimension <code>d_size</code> by <code>d_size</code>.</p>
<p>The function <code>gsl_matrix_memcpy</code> is used on line 228 to copy the contents of matrix <code>V_e</code> to matrix <code>V_e_temp</code>, according to the <a href="https://www.gnu.org/software/gsl/manual/html_node/Copying-matrices.html">documentation</a>. Note that <code>V_e</code> is an input to the function, while <code>V_e_temp</code> is defined as a <code>d_size</code> by <code>d_size</code> matrix in line 222.</p>
<p>Looking at the first line of the function, it seems peculiar to me that some of the <code>gsl_matrix</code> terms are preceded by <code>const</code>. What does this mean? <a href="https://www.gnu.org/software/gsl/manual/html_node/Matrix-views.html">This documentation</a> may answer my question.</p>
<p>By searching the repository, I see that the function <code>EigenDecomp</code> is in lapack.h. But I’m struggling to find documentation for the actual function. It looks like LAPACK is written in Fortran90, according to <a href="https://en.wikipedia.org/wiki/LAPACK">Wikipedia</a>.</p>
<p>I now see that the file lapack.cpp contains the code for the function <code>EigenDecomp</code>. See the full code <a href="https://github.com/xiangzhou/GEMMA/blob/0885df136fcbe42b1665998f293953cfe8d216c6/src/lapack.cpp#L296-L379">here</a>. It’s interesting that there are two functions with the same name. They differ in use of ‘float’ objects. For the <code>EigenDecomp</code> without floats, we see that, when using LAPACK, the function <code>lapack_eigen_decomp</code> is used. <code>lapack_eigen_decomp</code> is defined starting at line 234 of lapack.cpp. Zhou’s comment tells us that the first input is ‘destroyed’, i.e., over-written, when the function runs.</p>
</div>
<div id="calcqi" class="section level2">
<h2><code>CalcQi</code></h2>
<p>Zhou’s <a href="https://github.com/xiangzhou/GEMMA/blob/338bf7b7db8805515597d9e2d4b5dcbe2e40dfd1/src/mvlmm.cpp#L309">comment</a> tells us that</p>
<p><span class="math display">\[Qi=(\sum_{k=1}^n x_kx_k^T\otimes(delta_k*Dl+I)^{-1} )^{-1}\]</span></p>
<p>In examining the code for <code>CalcQi</code>, we see that he first calculates the entries for the matrix <code>Q</code>. Part of the code is <a href="https://github.com/xiangzhou/GEMMA/blob/338bf7b7db8805515597d9e2d4b5dcbe2e40dfd1/src/mvlmm.cpp#L328-L333">here</a>. He also uses the symmetry of <code>Q</code> to do only the needed calculations. The number <code>d</code> that gets entered into <code>Q</code> is related to the inner product of two rows of the <code>X</code> matrix, except that each term in the sum (ie, inner product) has a distinct weight; namely, <span class="math inline">\(Dl * \delta_k+ 1\)</span>, where <span class="math inline">\(\delta_k\)</span> differs for each component of the inner product.</p>
<p>After calculating all entries for matrix <code>Q</code>, he calls three distinct functions in the code <a href="https://github.com/xiangzhou/GEMMA/blob/338bf7b7db8805515597d9e2d4b5dcbe2e40dfd1/src/mvlmm.cpp#L345-L348">here</a>.</p>
<p><code>LUDecomp</code> is defined in <a href="https://github.com/xiangzhou/GEMMA/blob/03d7d2556a9284dc0ac3e155b5c9a8d69b1b21ee/src/lapack.cpp#L464-L468">lapack.cpp</a>.</p>
<p>We see that it calls the function <code>gsl_linalg_LU_decomp</code>, which is <a href="https://www.gnu.org/software/gsl/manual/html_node/LU-Decomposition.html">part of the GSL library</a>. It takes 3 arguments: a matrix, a permutation (matrix), and an integer. Note the structure of the output:</p>
<blockquote>
<p>These functions factorize the square matrix A into the LU decomposition PA = LU. On output the diagonal and upper triangular part of the input matrix A contain the matrix U. The lower triangular part of the input matrix (excluding the diagonal) contains L. The diagonal elements of L are unity, and are not stored.</p>
</blockquote>
<p>The <a href="https://en.wikipedia.org/wiki/LU_decomposition">LU Decomposition wikipedia page</a> is informative.</p>
<p>Note that the output of <code>LUDecomp</code> is stored as <code>Q</code>.</p>
<p>We then proceed to a line with <a href="https://github.com/xiangzhou/GEMMA/blob/338bf7b7db8805515597d9e2d4b5dcbe2e40dfd1/src/mvlmm.cpp#L346"><code>LUInvert</code></a>. <code>Q</code>, ie, the output of <code>LUDecomp</code>, is passed to <code>LUInvert</code>. What are the arguments to <code>LUInvert</code>?</p>
<p>The <a href="https://github.com/xiangzhou/GEMMA/blob/03d7d2556a9284dc0ac3e155b5c9a8d69b1b21ee/src/lapack.cpp#L500">key line</a> in <code>LUInvert</code> is a call to the GSL function <code>gsl_linalg_LU_invert</code>. Checking the <a href="https://www.gnu.org/software/gsl/manual/html_node/LU-Decomposition.html">documentation for <code>gsl_linalg_LU_invert</code></a>, we see that</p>
<blockquote>
<p>These functions compute the inverse of a matrix A from its LU decomposition (LU,p), storing the result in the matrix inverse. The inverse is computed by solving the system A x = b for each column of the identity matrix. It is preferable to avoid direct use of the inverse whenever possible, as the linear solver functions can obtain the same result more efficiently and reliably (consult any introductory textbook on numerical linear algebra for details).</p>
</blockquote>
<p>The matrix inverse gets passed to the function <a href="https://github.com/xiangzhou/GEMMA/blob/338bf7b7db8805515597d9e2d4b5dcbe2e40dfd1/src/mvlmm.cpp#L348"><code>LULndet</code></a>, which is defined in the file <a href="https://github.com/xiangzhou/GEMMA/blob/03d7d2556a9284dc0ac3e155b5c9a8d69b1b21ee/src/lapack.cpp#L533-L538">lapack.cpp</a></p>
<p>The key line is that containing a call to the function <code>gsl_linalg_LU_lndet</code>. We find documentation of the function <a href="https://www.gnu.org/software/gsl/manual/html_node/LU-Decomposition.html">here</a>.</p>
<p>Lines to free the memory complete the function.</p>
</div>
<div id="calcomega" class="section level2">
<h2><code>CalcOmega</code></h2>
<p><a href="https://github.com/xiangzhou/GEMMA/blob/338bf7b7db8805515597d9e2d4b5dcbe2e40dfd1/src/mvlmm.cpp#L389-L408">Lines</a> of mvlmm.cpp contain code for <code>CalcOmega</code>.</p>
<p>They define the matrices <code>OmegaU</code> and <code>OmegaE</code>. Note that the two omega matrices differ by a multiplicative factor.</p>
</div>
<div id="updateu" class="section level2">
<h2><code>UpdateU</code></h2>
<p><a href="https://github.com/xiangzhou/GEMMA/blob/338bf7b7db8805515597d9e2d4b5dcbe2e40dfd1/src/mvlmm.cpp#L411-L418"><code>UpdateU</code></a> is defined in <code>mvlmm.cpp</code>.</p>
<p><code>gsl_matrix_sub</code> is a matrix subtraction, in which the second argument is subtracted from the first argument and stored as the first argument. See the documentation <a href="https://www.gnu.org/software/gsl/manual/html_node/Matrix-operations.html">here</a></p>
<p>The last line of <code>UpdateU</code> contains a call to <a href="https://github.com/xiangzhou/GEMMA/blob/338bf7b7db8805515597d9e2d4b5dcbe2e40dfd1/src/mvlmm.cpp#L416"><code>gsl_matrix_mul_elements</code></a>, which is element-wise multiplication of matrices:</p>
<blockquote>
<p>This function multiplies the elements of matrix a by the elements of matrix b. The result a(i,j) a(i,j) * b(i,j) is stored in a and b remains unchanged. The two matrices must have the same dimensions.</p>
</blockquote>
</div>
<div id="updatee" class="section level2">
<h2><code>UpdateE</code></h2>
<p><code>UpdateE</code> is the <a href="https://github.com/xiangzhou/GEMMA/blob/338bf7b7db8805515597d9e2d4b5dcbe2e40dfd1/src/mvlmm.cpp#L421-L428">next function defined in mvlmm.cpp</a>.</p>
<p>First, note that <code>gsl_matrix_memcpy</code> copies the second argument’s elements to the first input’s elements. So, <code>gsl_matrix_memcpy(A, B)</code> assigns A to be a copy of B. Note that Zhou uses this function when he knows that subsequent steps will overwrite the matrix B, but B needs to be preserved.</p>
</div>
<div id="updatel_b" class="section level2">
<h2><code>UpdateL_B</code></h2>
<p><code>UpdateL_B</code> is a <a href="https://github.com/xiangzhou/GEMMA/blob/338bf7b7db8805515597d9e2d4b5dcbe2e40dfd1/src/mvlmm.cpp#L432-L447">slightly longer function than the previous update functions.</a></p>
<p>I copy its code here:</p>
<pre class="rcpp"><code>void UpdateL_B (const gsl_matrix *X, const gsl_matrix *XXti, const gsl_matrix *UltVehiY, const gsl_matrix *UltVehiU, gsl_matrix *UltVehiBX, gsl_matrix *UltVehiB)
{
    size_t c_size=X-&gt;size1, d_size=UltVehiY-&gt;size1;

    gsl_matrix *YUX=gsl_matrix_alloc (d_size, c_size);

    gsl_matrix_memcpy (UltVehiBX, UltVehiY);
    gsl_matrix_sub (UltVehiBX, UltVehiU);

    gsl_blas_dgemm(CblasNoTrans, CblasTrans, 1.0, UltVehiBX, X, 0.0, YUX);
    gsl_blas_dgemm(CblasNoTrans, CblasNoTrans, 1.0, YUX, XXti, 0.0, UltVehiB);

    gsl_matrix_free(YUX);

    return;
}</code></pre>
<p>We see that the code allocates a matrix, <code>YUX</code>, with dimensions <code>d_size</code> by <code>c_size</code>. It then copies input <code>UltVehiY</code> to matrix <code>UltVehiBX</code> before overwriting <code>UltVehiBX</code> by <code>UltVehiBX - UltVehiU</code>. Next are two calls to the function <code>gsl_blas_dgemm</code>. We need to think about what these calls do.</p>
<p>The <a href="https://www.gnu.org/software/gsl/manual/html_node/Level-3-GSL-BLAS-Interface.html">documentation</a> tells us that <code>gsl_blas_dgemm</code> is one of a family of functions that computes a matrix multiplication.</p>
<blockquote>
<p>These functions compute the matrix-matrix product and sum C = op(A) op(B) + C where op(A) = A, A^T, A^H for TransA = CblasNoTrans, CblasTrans, CblasConjTrans and similarly for the parameter TransB.</p>
</blockquote>
<blockquote>
<p>Function: int gsl_blas_dgemm (CBLAS_TRANSPOSE_t TransA, CBLAS_TRANSPOSE_t TransB, double alpha, const gsl_matrix * A, const gsl_matrix * B, double beta, gsl_matrix * C)</p>
</blockquote>
<p>Thus the line <code>gsl_blas_dgemm(CblasNoTrans, CblasTrans, 1.0, UltVehiBX, X, 0.0, YUX);</code> calculates the product <code>UltVehiBX * t(X)</code> where t(X) denotes the transpose of X and <code>*</code> denotes matrix multiplication, since the value of <code>beta</code> here is 0.0 (and <code>alpha</code> is 1.0). The result is stored as <code>YUX</code>.</p>
<p>Finally, we calculate the matrix product <code>YUX * XXti</code> and stored it as <code>UltVehiB</code>.</p>
</div>
<div id="updaterl_b" class="section level2">
<h2><code>UpdateRL_B</code></h2>
<pre class="rcpp"><code>void UpdateRL_B (const gsl_vector *xHiy, const gsl_matrix *Qi, gsl_matrix *UltVehiB)
{
    size_t d_size=UltVehiB-&gt;size1, c_size=UltVehiB-&gt;size2, dc_size=Qi-&gt;size1;

    gsl_vector *b=gsl_vector_alloc (dc_size);

    //calculate b=Qiv
    gsl_blas_dgemv(CblasNoTrans, 1.0, Qi, xHiy, 0.0, b);

    //copy b to UltVehiB
    for (size_t i=0; i&lt;c_size; i++) {
        gsl_vector_view UltVehiB_col=gsl_matrix_column (UltVehiB, i);
        gsl_vector_const_view b_subcol=gsl_vector_const_subvector (b, i*d_size, d_size);
        gsl_vector_memcpy (&amp;UltVehiB_col.vector, &amp;b_subcol.vector);
    }

    gsl_vector_free(b);

    return;
}</code></pre>
<p>The line <code>gsl_blas_dgemv(CblasNoTrans, 1.0, Qi, xHiy, 0.0, b);</code> uses the function <code>gsl_blas_dgemv</code>, which is documented <a href="https://www.gnu.org/software/gsl/manual/html_node/Level-2-GSL-BLAS-Interface.html">here</a>.</p>
<blockquote>
<p>Function: int gsl_blas_dgemv (CBLAS_TRANSPOSE_t TransA, double alpha, const gsl_matrix * A, const gsl_vector * x, double beta, gsl_vector * y)</p>
</blockquote>
<blockquote>
<p>These functions compute the matrix-vector product and sum y = op(A) x + y, where op(A) = A, A^T, A^H for TransA = CblasNoTrans, CblasTrans, CblasConjTrans.</p>
</blockquote>
<p>The line of code thus means that we calculate <code>Qi * xHiy</code> and store the result as <code>b</code>. Note that both <code>Qi</code> and <code>xHiy</code> are inputs to this function.</p>
<p>Let’s examine the code within the loop.</p>
<p><code>gsl_matrix_column</code> is documented <a href="https://www.gnu.org/software/gsl/manual/html_node/Creating-row-and-column-views.html">here</a>.</p>
<blockquote>
<p>Function: gsl_vector_view gsl_matrix_column (gsl_matrix * m, size_t j)</p>
</blockquote>
<blockquote>
<p>These functions return a vector view of the j-th column of the matrix m. The data pointer of the new vector is set to null if j is out of range.</p>
</blockquote>
<blockquote>
<p>The function gsl_vector_const_column is equivalent to gsl_matrix_column but can be used for matrices which are declared const.</p>
</blockquote>
<p>We see that for each iteration of the loop, we choose a column from <code>UltVehiB</code>, ie, we choose the <span class="math inline">\(i^{th}\)</span> column, and assign it to the object <code>UltVehiB_col</code>.</p>
<p>The function is documented <a href="https://www.gnu.org/software/gsl/manual/html_node/Vector-views.html">here</a>.</p>
<blockquote>
<p>Function: gsl_vector_const_view gsl_vector_const_subvector (const gsl_vector * v, size_t offset, size_t n)</p>
</blockquote>
<blockquote>
<p>These functions return a vector view of a subvector of another vector v. The start of the new vector is offset by offset elements from the start of the original vector. The new vector has n elements. Mathematically, the i-th element of the new vector v’ is given by,</p>
</blockquote>
<blockquote>
<p>v’(i) = v-&gt;data[(offset + i)*v-&gt;stride] where the index i runs from 0 to n-1.</p>
</blockquote>
<blockquote>
<p>The data pointer of the returned vector struct is set to null if the combined parameters (offset,n) overrun the end of the original vector.</p>
</blockquote>
<blockquote>
<p>The new vector is only a view of the block underlying the original vector, v. The block containing the elements of v is not owned by the new vector. When the view goes out of scope the original vector v and its block will continue to exist. The original memory can only be deallocated by freeing the original vector. Of course, the original vector should not be deallocated while the view is still in use.</p>
</blockquote>
<blockquote>
<p>The function gsl_vector_const_subvector is equivalent to gsl_vector_subvector but can be used for vectors which are declared const.</p>
</blockquote>
<p>Together, the lines contained in the <code>for</code> loop serve to copy the elements of the vector <code>b</code> into the matrix <code>UltVehiB</code>, where each element of <code>b</code> is entered exactly once into <code>UltVehiB</code>.</p>
</div>
<div id="updatev" class="section level2">
<h2><code>UpdateV</code></h2>
<p>This function serves to update both <code>Ve</code> and <code>Vg</code>.</p>
<pre class="rcpp"><code>void UpdateV (const gsl_vector *eval, const gsl_matrix *U, const gsl_matrix *E, const gsl_matrix *Sigma_uu, const gsl_matrix *Sigma_ee, gsl_matrix *V_g, gsl_matrix *V_e)
{
    size_t n_size=eval-&gt;size, d_size=U-&gt;size1;

    gsl_matrix_set_zero (V_g);
    gsl_matrix_set_zero (V_e);

    double delta;

    //calculate the first part: UD^{-1}U^T and EE^T
    for (size_t k=0; k&lt;n_size; k++) {
        delta=gsl_vector_get (eval, k);
        if (delta==0) {continue;}

        gsl_vector_const_view U_col=gsl_matrix_const_column (U, k);
        gsl_blas_dsyr (CblasUpper, 1.0/delta, &amp;U_col.vector, V_g);
    }

    gsl_blas_dsyrk(CblasUpper, CblasNoTrans, 1.0, E, 0.0, V_e);

    //copy the upper part to lower part
    for (size_t i=0; i&lt;d_size; i++) {
        for (size_t j=0; j&lt;i; j++) {
            gsl_matrix_set (V_g, i, j, gsl_matrix_get(V_g, j, i));
            gsl_matrix_set (V_e, i, j, gsl_matrix_get(V_e, j, i));
        }
    }

    //add Sigma
    gsl_matrix_add (V_g, Sigma_uu);
    gsl_matrix_add (V_e, Sigma_ee);

    //scale by 1/n
    gsl_matrix_scale (V_g, 1.0/(double)n_size);
    gsl_matrix_scale (V_e, 1.0/(double)n_size);

    return;
}</code></pre>
<p>We first set to matrices of zeros the objects <code>Vg</code> and <code>Ve</code>.</p>
<p>The function <code>gsl_blas_dsyr</code> is used in the <code>for</code> loop over <code>k</code>. We need to look at its purpose.</p>
<blockquote>
<p>Function: int gsl_blas_dsyr (CBLAS_UPLO_t Uplo, double alpha, const gsl_vector * x, gsl_matrix * A) These functions compute the symmetric rank-1 update A = x x^T + A of the symmetric matrix A. Since the matrix A is symmetric only its upper half or lower half need to be stored. When Uplo is CblasUpper then the upper triangle and diagonal of A are used, and when Uplo is CblasLower then the lower triangle and diagonal of A are used.</p>
</blockquote>
<p>The line <code>gsl_blas_dsyr (CblasUpper, 1.0/delta, &amp;U_col.vector, V_g);</code> thus tells us to use the upper portion of the <code>V_g</code> matrix (and the diagonal) and to add to (the current value of) <code>V_g</code> the matrix formed by the (matrix multiplication) product of a column of U with its transpose, with each entry of Ucolumn t(Ucolumn) divided by delta. Note that <code>delta</code> is the <span class="math inline">\(k^{th}\)</span> eigenvalue, so it changes with it iteration of the <code>for</code> loop.</p>
<p>After completing the <code>for</code> loop over <code>k</code>, we have the line with the function: <code>gsl_blas_dsyrk</code>. This function is documented <a href="https://www.gnu.org/software/gsl/manual/html_node/Level-3-GSL-BLAS-Interface.html">here</a>.</p>
<blockquote>
<p>Function: int gsl_blas_dsyrk (CBLAS_UPLO_t Uplo, CBLAS_TRANSPOSE_t Trans, double alpha, const gsl_matrix * A, double beta, gsl_matrix * C)</p>
</blockquote>
<blockquote>
<p>These functions compute a rank-k update of the symmetric matrix C, C = A A^T + C when Trans is CblasNoTrans and C = A^T A + C when Trans is CblasTrans. Since the matrix C is symmetric only its upper half or lower half need to be stored. When Uplo is CblasUpper then the upper triangle and diagonal of C are used, and when Uplo is CblasLower then the lower triangle and diagonal of C are used.</p>
</blockquote>
<p>Thus, we interpret the line <code>gsl_blas_dsyrk(CblasUpper, CblasNoTrans, 1.0, E, 0.0, V_e);</code> to be calculating the matrix <span class="math inline">\(EE^T\)</span> and assigning it to the value <code>V_e</code>.</p>
<p><code>gsl_matrix_add</code> is for addition of two matrices, where the first input is overwritten by the sum.</p>
<blockquote>
<p>Function: int gsl_matrix_add (gsl_matrix * a, const gsl_matrix * b) This function adds the elements of matrix b to the elements of matrix a. The result a(i,j) a(i,j) + b(i,j) is stored in a and b remains unchanged. The two matrices must have the same dimensions.</p>
</blockquote>
<p><code>gsl_matrix_scale</code> multiplies each element of a matrix by a scalar.</p>
<p>Thus, the line</p>
<p><code>gsl_matrix_scale (V_g, 1.0/(double)n_size);</code></p>
<p>leads to each entry of <code>V_g</code> being divided by <code>n_size</code> (with the result stored as the new value of <code>V_g</code>).</p>
</div>

    </div>
  </article>

  
<section id="comments">
  <div id="disqus_thread"></div>
  <script>
  var disqus_config = function () {
  
  };
  (function() {
    var inIFrame = function() {
      var iframe = true;
      try { iframe = window.self !== window.top; } catch (e) {}
      return iframe;
    };
    if (inIFrame()) return;
    var d = document, s = d.createElement('script');
    s.src = '//fredsblog2.disqus.com/embed.js'; s.async = true;
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
  })();
  </script>
  <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</section>



</main>

      <footer class="footer">
        <ul class="footer-links">
          <li>
            <a href="../../../../index.xml" type="application/rss+xml" target="_blank">RSS feed</a>
          </li>
          <li>
            <a href="https://gohugo.io/" class="footer-links-kudos">Made with <img src="../../../../images/hugo-logo.png" width="22" height="22"></a>
          </li>
        </ul>
      </footer>

    </div>
    



<script src="//cdn.bootcss.com/highlight.js/9.11.0/highlight.min.js"></script>



<script src="//cdn.bootcss.com/highlight.js/9.11.0/languages/r.min.js"></script>
<script src="//cdn.bootcss.com/highlight.js/9.11.0/languages/yaml.min.js"></script>
<script>hljs.configure({languages: []}); hljs.initHighlightingOnLoad();</script>



    
<script src="../../../../js/math-code.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [['$','$'], ['\\(','\\)']],
    processEscapes: true
  }
});
</script>
<script async src="//cdn.bootcss.com/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>


    
<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-46757486-5', 'auto');
ga('send', 'pageview');
</script>

  </body>
</html>

