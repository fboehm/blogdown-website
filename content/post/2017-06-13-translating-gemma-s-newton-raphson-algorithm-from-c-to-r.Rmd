---
title: Translating GEMMAâ€™s Newton-Raphson Algorithm from C++ to R
author: Frederick Boehm
date: '2017-06-13'
slug: translating-gemma-s-newton-raphson-algorithm-from-c-to-r
draft: 'true'
categories:
  - Computing
tags:
  - Newton-Raphson
  - Linear mixed effects models
  - Variance components
  - R
---

## Overview

We want to translate GEMMA's C++ code in the function `MphNR` (in the file `mvlmm.cpp`) into R code as a way to better understand the calculations and the algorithm.

### `MphNR` C++ Code

`MphNR` is defined in [these lines](https://github.com/xiangzhou/GEMMA/blob/3ed15d7061fdac57c07da0fba087e9e69ac0ec42/src/mvlmm.cpp#L2504-L2662) in the GEMMA Github repository. 

### R code for `MphNR`

```{r}
MphNR <- function(){
  n_size <- length(eval)
  c_size <- nrow(X)
  d_size <- nrow(Y)
  dc_size <- d_size * c_size
  v_size <- d_size * (d_size + 1) / 2
  XXt <- X %*% t(X)
  log(det(XXt)) -> lndetXXt
  if (func_name == "R"){
    logl_const <- - 0.5 * (n_size - c_size) * d_size * log(2 * pi) + 0.5 * d_size * lndetXXt
  }
  for (t in 1:max_iter){
    Vg_save <- V_g
    Ve_save <- V_e
    step_scale <- 1
    step_iter <- 0
    while((flag_pd == 0 | logl_new<logl_old | logl_new - logl_old > 10 ) & step_iter < 10){
      V_g <- Vg_save
      V_e <- Ve_save
      if (t > 1){UpdateVeVg()}
      flag_pd <- matrixcalc::is.positive.definite(V_g) & matrixcalc::is.positive.definite(V_e)
			if (flag_pd == 1) {
			  if (func_name=='R') {
					logl_new <- logl_const - 0.5 * logdet_H - 0.5 * logdet_Q - 0.5 * yPy
			  }
			}
      step_scale <- step_scale / 2
      step_iter <- step_iter + 1
    } # end of while loop
    if (t > 1){
      if (logl_new < logl_old | flag_pd == 0) {
				V_g <- Vg_save
				V_e <- Ve_save
				break
      }
      if (logl_new - logl_old < max_prec) {
				break
      }
    logl_old <- logl_new
    CalcDev()
    }
  } # end of loop over t
  return(logl_new)
} # end of function
```

The [do-while loop](https://github.com/xiangzhou/GEMMA/blob/3ed15d7061fdac57c07da0fba087e9e69ac0ec42/src/mvlmm.cpp#L2553-L2598) is a construction that I haven't seen before in C++. We can translate it into R by using a `while` loop.

`flag_pd` is an indicator for positive-definite matrices.

### `CalcHiQi`

`CalcHiQi` is defined [here](https://github.com/xiangzhou/GEMMA/blob/898770748aa87ad89a5ca10282141fae7f4cbbd5/src/mvlmm.cpp#L961-L1022) in GEMMA.

```{r}
CalcHiQi <- function(){
  n_size <- length(eval)
  c_size <- nrow(X)
  d_size <- nrow(V_g)
  ep_out <- eigen_proc(V_g, V_e) # I defined eigen_proc() in my earlier blog post from may 24, 2017
  ep_out[[1]] -> logdet_Ve
  ep_out[[2]] -> UltVeh
  ep_out[[3]] -> UltVehi
  ep_out[[4]] -> D_l
  logdet_H <- n_size * logdet_Ve
  for (k in 1:n_size){
    #delta=gsl_vector_get (eval, k);
    delta <- eval[k]
    #gsl_matrix_memcpy (mat_dd, UltVehi);
    mat_dd <- UltVehi
    #for(size_t i=0; i<d_size; i++) {
		for (i in 1:d_size){
    	#dl=gsl_vector_get(D_l, i);
      dl <- D_l[i]
    	#d=delta*dl+1.0;
      d <- delta * dl + 1
			#gsl_vector_view mat_row=gsl_matrix_row (mat_dd, i);
			mat_row <- mat_dd[i, ]
      #gsl_vector_scale (&mat_row.vector, 1.0/d);
      mat_row <- mat_row / d
      mat_row -> mat_dd[i, ]
			#logdet_H+=log(d);
      logdet_H <- logdet_H + log(d)
		}
    #gsl_matrix_view Hi_k=gsl_matrix_submatrix(Hi_all, 0, k*d_size, d_size, d_size);
		Hi_k <- Hi_all[1:d_size, ((k - 1) * d_size + 1):(k * d_size)]
    #gsl_blas_dgemm(CblasTrans, CblasNoTrans, 1.0, UltVehi, mat_dd, 0.0, &Hi_k.matrix);
		Hi_k <- t(UltVehi) %*% mat_dd
		Hi_k -> Hi_all[1:d_size, ((k - 1) * d_size + 1):(k * d_size)]
  }
  #logdet_Q=CalcQi (eval, D_l, X, Qi)-(double)c_size*logdet_Ve;
  cq_out <- calc_qi(eval, D_l, X)
  cq_out[[1]] -> Qi
  cq_out[[2]] - c_size * logdet_Ve -> logdet_Q
  #for (size_t i=0; i<c_size; i++) {
	for (i in 1:c_size){
  	#for (size_t j=0; j<c_size; j++) {
		for (j in 1:c_size){
	  	#gsl_matrix_view Qi_sub=gsl_matrix_submatrix (Qi, i*d_size, j*d_size, d_size, d_size);
			Qi_sub <- Qi[((i - 1) * d_size + 1):(i * d_size), ((j - 1) * d_size + 1):(j * d_size)]
		  #if (j<i) {
			if (j < i){
				#gsl_matrix_view Qi_sym=gsl_matrix_submatrix (Qi, j*d_size, i*d_size, d_size, d_size);
				Qi_sym <- Qi[((j - 1) * d_size + 1):(j * d_size), ((i - 1) * d_size + 1):(i * d_size)]
			  #gsl_matrix_transpose_memcpy (&Qi_sub.matrix, &Qi_sym.matrix);
				t(Qi_sym) -> Qi_sub
				Qi_sub -> Qi[((i - 1) * d_size + 1):(i * d_size), ((j - 1) * d_size + 1):(j * d_size)]
			#} else {
			} else {
				#gsl_blas_dgemm(CblasNoTrans, CblasNoTrans, 1.0, &Qi_sub.matrix, UltVeh, 0.0, mat_dd);
				mat_dd <- Qi_sub %*% UltVeh
			  #gsl_blas_dgemm(CblasTrans, CblasNoTrans, 1.0, UltVeh, mat_dd, 0.0, &Qi_sub.matrix);
				t(UltVeh) %*% mat_dd -> Qi_sub
				Qi_sub -> Qi[((i - 1) * d_size + 1):(i * d_size), ((j - 1) * d_size + 1):(j * d_size)]
			}
		}
	}
  return(list(logdet_H, Qi))
}
  
```

**I need to revise the above code in light of what i just learned about matrix (and vector) views.**




### `Calc_Hiy_all`


### `Calc_xHi_all`


### `Calc_xHiy`


### `Calc_yHiy`


### `CalcDev`

