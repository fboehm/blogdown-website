---
title: Deciphering GEMMAâ€™s C++ Code
author: Frederick Boehm
date: '`r lubridate::now()`'
slug: deciphering-gemma-s-c-code
draft: 'true'
categories:
  - Computing
tags:
  - Genetics
  - EM algorithm
  - Linear mixed effects models
  - Variance components
  - R
---

My goal is to  translate the C++ code in [`GEMMA/src/mvlmm.cpp`](https://github.com/xiangzhou/GEMMA/blob/master/src/mvlmm.cpp) to mathematical notation and, ultimately, to R code. Zhou's C++ code uses the gsl C++ library. 


## `CalcXHiY` C++ code

Let's examine the function `CalcXHiY` which runs from line [357-384](https://github.com/xiangzhou/GEMMA/blob/793ba025de8e71b49e738613e8dd9bbdd06389d4/src/mvlmm.cpp#L357-L384) of `mvlmm.cpp`. I reproduce them here:

```{Rcpp, eval = FALSE}
void CalcXHiY(const gsl_vector *eval, const gsl_vector *D_l, const gsl_matrix *X, const gsl_matrix *UltVehiY, gsl_vector *xHiy)
{
	size_t n_size=eval->size, c_size=X->size1, d_size=D_l->size;

	gsl_vector_set_zero (xHiy);

	double x, delta, dl, y, d;
	for (size_t i=0; i<d_size; i++) {
		dl=gsl_vector_get(D_l, i);
		for (size_t j=0; j<c_size; j++) {
			d=0.0;
			for (size_t k=0; k<n_size; k++) {
				x=gsl_matrix_get(X, j, k);
				y=gsl_matrix_get(UltVehiY, i, k);
				delta=gsl_vector_get(eval, k);
				d+=x*y/(delta*dl+1.0);
			}
			gsl_vector_set(xHiy, j*d_size+i, d);
		}
	}
	/*
	cout<<"xHiy: "<<endl;
	for (size_t i=0; i<(d_size*c_size); i++) {
		cout<<gsl_vector_get(xHiy, i)<<endl;
	}
	 */
	return;
}

```

We see that Zhou uses four gsl functions repeatedly:

1. `gsl_matrix_get`
2. `gsl_matrix_set`
3. `gsl_vector_set`
4. `gsl_vector_get`

From reading the documentation for these four functions - [here](https://www.gnu.org/software/gsl/manual/html_node/Accessing-matrix-elements.html) and [here](https://www.gnu.org/software/gsl/manual/html_node/Accessing-vector-elements.html) - my understanding is that the functions whose names end in `get` return a subset of an existing matrix or vector. For instance, the line from above:

```{Rcpp, eval = FALSE}
dl=gsl_vector_get(D_l, i);
```

assigns to `dl` the $i^{th}$ element of the vector `D_l`.

The functions that end in `set` assign a value to a given element of a matrix or vector. `gsl_vector_set` requires 3 arguments, since we need to know the name of the vector, which element is to be replaced, and the value to insert at the position of replacement. 

```{rcpp, eval = FALSE}
gsl_vector_set(xHiy, j*d_size+i, d);
```

The code immediately above means that the value `d` is inserted into vector `xHiy` at position `j*d_size+i`. 

[One of the first lines](https://github.com/xiangzhou/GEMMA/blob/793ba025de8e71b49e738613e8dd9bbdd06389d4/src/mvlmm.cpp#L361) in the function creates the vector `xHiy` and sets all of its entries to zero:

```{rcpp, eval = FALSE}
gsl_vector_set_zero (xHiy);
```

The line 

```{rcpp, eval = FALSE}
x=gsl_matrix_get(X, j, k);
```

assigns to the value `x` the $(j, k)^{th}$ element of matrix X. 


```{rcpp, eval = FALSE}
y=gsl_matrix_get(UltVehiY, i, k);
```

assigns to `y` the $(i, k)^{th}$ element of `UltVehiY`. 

Presumably `eval` is Zhou's abbreviation of eigenvalues. `d` then is the $k^{th}$ eigenvalue from the decomposition of the kinship matrix.

`x*y`, refers to the product of two numbers. 

```{rcpp, eval = FALSE}
d+=x*y/(delta*dl+1.0);
```

defines `d` to be the sum of the current value of `d` and `x*y/(delta*dl+1.0)`. In R, we would write this as:

```{r, eval = FALSE}
d <- d + x * y / (delta * dl + 1)
```

Note that each time we restart the loop over `k` we reset the value of `d` to zero. Note also that `1.0` is the value of every eigenvalue of the identity matrix. 

The use of `1.0` rather than merely `1` seems peculiar to me - I'm new to C++. I imagine that `1` and `1.0` might be stored differently, which might justify the use of `1.0` over `1`. 

Since we're looping over `k`, it's as if we're taking the inner (dot) product of two vectors and defining it to be the number `d` (after the looping over k).

## EigenProc

I want to understand the function `EigenProc`, which occupies [lines 215-307](https://github.com/xiangzhou/GEMMA/blob/0885df136fcbe42b1665998f293953cfe8d216c6/src/mvlmm.cpp#L215-L307) of `mvlmm.cpp`.

The first several lines allocate matrices with dimension `d_size` by `d_size`.

The function `gsl_matrix_memcpy` is used on line 228 to copy the contents of matrix `V_e` to matrix `V_e_temp`, according to the [documentation](https://www.gnu.org/software/gsl/manual/html_node/Copying-matrices.html). Note that `V_e` is an input to the function, while `V_e_temp` is defined as a `d_size` by `d_size` matrix in line 222. 

Looking at the first line of the function, it seems peculiar to me that some of the `gsl_matrix` terms are preceded by `const`. What does this mean? [This documentation](https://www.gnu.org/software/gsl/manual/html_node/Matrix-views.html) may answer my question.

By searching the repository, I see that the function `EigenDecomp` is in lapack.h. But I'm struggling to find documentation for the actual function. It looks like LAPACK is written in Fortran90, according to [Wikipedia](https://en.wikipedia.org/wiki/LAPACK).

I now see that the file lapack.cpp contains the code for the function `EigenDecomp`. See the full code [here](https://github.com/xiangzhou/GEMMA/blob/0885df136fcbe42b1665998f293953cfe8d216c6/src/lapack.cpp#L296-L379). It's interesting that there are two functions with the same name. They differ in use of 'float' objects. For the `EigenDecomp` without floats, we see that, when using LAPACK, the function `lapack_eigen_decomp` is used. `lapack_eigen_decomp` is defined starting at line 234 of lapack.cpp. Zhou's comment tells us that the first input is 'destroyed', i.e., over-written, when the function runs.













